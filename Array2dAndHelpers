//Array2DB struct
enum CellState {
    case dead, alive, makeDead, makeAlive
}

struct Cell {
    var state:CellState
    var nextState:CellState?
    
    init(state:CellState) {
        self.state = state
    }
}

struct Array2DB:CustomStringConvertible {
    var values: [Cell]
    let rows: Int
    let cols: Int
    
    //creates the 2-dimensional abstraction of our 'values' array
    var description: String {
        var d = ""
        for r in 0..<rows {
            for c in 0..<cols {
                if c == cols - 1 {
                    d += "\(values[getIndex(row: r, col: c)])\n" //redo
                } else {
                    d += "\(values[getIndex(row: r, col: c)])"
                }
            }
        }
        return d
    }
    
    var count:Int {
        return values.count
    }
    
    //a count of all the cells that are currently alive.
    var numberLivingCells:Int {
        var c = 0
        for i in values {
            if i.state == CellState.alive {
                c += 1
            }
        }
        return c
    }
    
    //creates an empty array of 0's according to the specified number of rows and cols
    init(rows: Int, cols: Int) {
        self.rows = rows
        self.cols = cols
        values = [Cell](repeating: Cell(state:CellState.dead), count: (rows+2)*(cols+2)) //TODO: redo so it works
    }
    
    //allows us to use the syntax [row, col] when interacting with an Array2DB
    subscript(row: Int, col: Int) -> Cell {
        get {
            return values[getIndex(row: row, col: col)]
        }
        set(newValue) {
            values[getIndex(row: row, col: col)] = newValue
        }
    }
    
    //converts the abstract idea of row, col to the corresponding index in 'values'
    func getIndex(row: Int, col: Int) -> Int {
        assert((row >= -1) && (row <= rows), "row \(row) is out of bounds")
        assert((col >= -1) && (col <= cols), "col \(col) is out of bounds")
        return (row + 1)*rows + col + 1
    }
    
}

class Colony:CustomStringConvertible {
    var name:String
    var array:Array2DB
    var exit = false
    
    var description:String {
        return "\(name)\n\(array)"
    }
    
    init(name:String, size:Int) {
        self.name = name
        self.array = Array2DB(rows:size, cols:size)
    }
    
    //sets a cell to become alive on the next run
    func setCellAlive(_ row:Int,_ col:Int) {
        array[row, col].state = CellState.makeAlive
    }
    
    //kill a cell for the next run
    func setCellDead(_ row:Int,_ col:Int) {
        array[row, col].state = CellState.makeDead
    }
    
    //reset
    func resetColony() {
        for r in 0..<array.rows {
            for c in 0..<array.cols {
                array[r, c].state = CellState.dead
            }
        }
    }
    
    //finds if the cell named is alive.
    func isCellAlive(_ row:Int,_ col:Int) -> CellState {
        return array[row, col].state
    }
    
    func numSurroundingCellsAlive(_ row:Int,_ col:Int) -> Int {
        var c:Int = 0
        let cellsToCheck = [(row-1,col-1), (row-1, col), (row-1, col+1), (row, col-1), (row, col+1), (row+1,col-1), (row+1, col), (row+1, col+1)]
        for check in cellsToCheck {
            if array[check.0, check.1].state == CellState.alive {
                c += 1
            }
        }
        
        return c
    }
    
    func evolve(forTurns t:Int = -1) {
        exit = false
        var i:Int = t
        while (t == -1 && !exit) || (i > 0 && i <= t) {
            //evolve()
            i -= 1
        }
    }
}

var a = Colony(name:"test colony", size:10)
a.setCellAlive(5,5)
a.setCellAlive(5,6)
a.setCellAlive(5,7)
a.setCellAlive(6,6)
print(a)

/*

+ + + + + +  row
+ x + + + +
+ + + + + +
+ + + + + +
+ + + + + +
+ + + + + +
  
  c
  o
  l

*/
